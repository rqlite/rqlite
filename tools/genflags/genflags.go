package main

import (
	"bytes"
	"log"
	"os"
	"text/template"

	"github.com/spf13/viper"
)

// Template for generating flags.go
const flagTemplate = `
// Code generated by go generate; DO NOT EDIT.
package main

import (
	"flag"
	"os"
)

// Config represents all configuration options.
type Config struct {
{{- range .Flags }}
	// {{ .ShortHelp }}
	{{ .Name }} {{ .GoType }}
{{- end }}
}

// ParseFlags sets up and parses command-line flags.
func ParseFlags() *Config {
	config := &Config{}
	fs := flag.NewFlagSet("rqlite", flag.ExitOnError)
{{- range .Flags }}
	{{- if eq .Type "string" }}
	fs.StringVar(&config.{{ .Name }}, "{{ .CLI }}", "", "{{ .ShortHelp }}")
	{{- else if eq .Type "bool" }}
	fs.BoolVar(&config.{{ .Name }}, "{{ .CLI }}", false, "{{ .ShortHelp }}")
	{{- else if eq .Type "int" }}
	fs.IntVar(&config.{{ .Name }}, "{{ .CLI }}", 0, "{{ .ShortHelp }}")
	{{- else if eq .Type "duration" }}
	fs.DurationVar(&config.{{ .Name }}, "{{ .CLI }}", 0, "{{ .ShortHelp }}")
	{{- end }}
{{- end }}
	fs.Parse(os.Args[1:])
	return config
}
`

// Flag represents a single flag configuration.
type Flag struct {
	Name      string `mapstructure:"name"`
	CLI       string `mapstructure:"cli"`
	Type      string `mapstructure:"type"`
	ShortHelp string `mapstructure:"short_help"`
	LongHelp  string `mapstructure:"long_help"`
}

// Convert the flag type to Go type.
func (f Flag) GoType() string {
	switch f.Type {
	case "string":
		return "string"
	case "bool":
		return "bool"
	case "int":
		return "int"
	case "duration":
		return "time.Duration"
	default:
		return "string" // Default to string
	}
}

func generateFlagsFile(flags []Flag) {
	// Parse the template.
	tmpl, err := template.New("flags").Funcs(template.FuncMap{
		"GoType": Flag.GoType,
	}).Parse(flagTemplate)
	if err != nil {
		log.Fatalf("Error parsing template: %v", err)
	}

	// Execute the template with the flags data.
	var output bytes.Buffer
	if err := tmpl.Execute(&output, struct {
		Flags []Flag
	}{Flags: flags}); err != nil {
		log.Fatalf("Error executing template: %v", err)
	}

	// Write the output to flags.go.
	if err := os.WriteFile("flags.go", output.Bytes(), 0644); err != nil {
		log.Fatalf("Error writing flags.go: %v", err)
	}
}

func main() {
	viper.SetConfigFile("../../flags/flags.toml")
	if err := viper.ReadInConfig(); err != nil {
		log.Fatalf("Error reading config file: %v", err)
	}

	var flags []Flag
	if err := viper.UnmarshalKey("flags", &flags); err != nil {
		log.Fatalf("Error unmarshaling config: %v", err)
	}

	// Generate flags.go
	generateFlagsFile(flags)
}
